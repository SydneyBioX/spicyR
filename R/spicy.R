#' Performs spatial tests on spatial cytometry data.
#'
#' @param cells A SegmentedCells or data frame that contains at least the 
#' variables x and y, giving the location coordinates of each cell, and cellType.
#' @param condition Vector of conditions to be tested corresponding to each image
#'  if cells is a data frame.
#' @param subject Vector of subject IDs corresponding to each image if cells is
#'  a data frame.
#' @param covariates Vector of covariate names that should be included in the 
#' mixed effects model as fixed effects.
#' @param from vector of cell types which you would like to compare to the to vector
#' @param to vector of cell types which you would like to compare to the from vector
#' @param dist The distance at which the statistic is obtained.
#' @param integrate Should the statistic be the integral from 0 to dist, or the 
#' value of the L curve at dist.
#' @param nsim Number of simulations to perform. If empty, the p-value from lmerTest is used.
#' @param verbose logical indicating whether to output messages.
#' @param weights logical indicating whether to include weights based on cell counts.
#' @param ... Other options to pass to bootstrap.
#'
#' @return Data frame of p-values.
#' @export
#'
#' @examples
#' data("melanomaResponders")
#'
#' # Test with random effect for patient on only one pairwise combination of cell types.
#' spicy(melanomaResponders, condition = "condition", subject = "subject", 
#'       from = "CD8+PD1+PDL1-", to = "CD8-PD1+PDL1+")
#' 
#' # Test all pairwise combination of cell types without random effect of patient.
#' #spicyTest <- spicy(melanomaResponders, condition = "condition")
#'
#' # Test all pairwise combination of cell types with random effect of patient.
#' #spicy(melanomaResponders, condition = "condition", subject = "subject")
#'
#' # Test all pairwise combination of cell types with random effect of patient using 
#' # a bootstrap to calculate significance.
#' #spicy(melanomaResponders, condition = "condition", subject = "subject", nsim = 199)
#' 
#' @aliases
#' spicy
#' spicy,spicy-method
#' @importFrom mgcv gam ti
spicy <- function(cells,
                  condition = NULL,
                  subject = NULL,
                  covariates = NULL,
                  from = NULL,
                  to = NULL,
                  dist = NULL,
                  integrate = TRUE,
                  nsim = NULL,
                  verbose = TRUE,
                  weights = TRUE,
                  ...) {
    if (!is(cells, "SegmentedCells")) {
        stop('cells needs to be a SegmentedCells object')
    }
    
    if (is.null(from))
        from <- as.character(unique(cellType(cells)))
    if (is.null(to))
        to <- as.character(unique(cellType(cells)))
    
    from <- as.character(unique(from))
    to <- as.character(unique(to))
    
    if (any((!to %in% cellType(cells)) |
            (!from %in% cellType(cells))))
        stop("to and from need to be cell type in your SegmentedCells")
    
    nCells <- table(imageID(cells), cellType(cells))
    
    ## Find pairwise associations
    
    m1 <- rep(from, times = length(to))
    m2 <- rep(to, each = length(from))
    labels <- paste(m1, m2, sep = "_")
    
    MoreArgs1 <- list(cells = cells, dist = dist)
    
    if (verbose)
        message("Calculating pairwise spatial associations")
    
    pairwiseAssoc <- mapply(getPairwise,
                            from = m1,
                            to = m2,
                            MoreArgs = MoreArgs1)
    colnames(pairwiseAssoc) <- labels
    
    count1 <- as.vector(nCells[, m1])
    count2 <- as.vector(nCells[, m2])
    
    resSq <-
        as.vector(apply(pairwiseAssoc, 2, function(x)
            (x - mean(x, na.rm = TRUE))^2))
    
    toWeight <- !is.na(as.vector(pairwiseAssoc))
    resSqToWeight <- resSq[toWeight]
    count1ToWeight <- count1[toWeight]
    count2ToWeight <- count2[toWeight]
    
    if (weights) {
        weightFunction <- gam(resSqToWeight ~ ti(count1ToWeight, count2ToWeight))
    } else {
        weightFunction <- NULL
    }
    
    pairwiseAssoc <- as.list(data.frame(pairwiseAssoc))
    names(pairwiseAssoc) <- labels
    
    ## Linear model
    if (is.null(subject) & !is.null(condition)) {
        if (verbose)
            message("Testing for spatial differences across conditions")
        
        MoreArgs2 <-
            list(
                cells = cells,
                condition = condition,
                covariates = covariates,
                weightFunction = weightFunction
            )
        
        linearModels <- mapply(
            spatialLM,
            spatAssoc = pairwiseAssoc,
            from = m1,
            to = m2,
            MoreArgs = MoreArgs2,
            SIMPLIFY = FALSE
        )
        
        df <- cleanLM(linearModels, nsim)
    }
    
    ## Mixed effects model
    if ((!is.null(subject)) & !is.null(condition)) {
        if (verbose)
            message(
                "Testing for spatial differences across conditions accounting for multiple images per subject"
            )
        
        MoreArgs2 <-
            list(
                cells = cells,
                subject = subject,
                condition = condition,
                covariates = covariates,
                weightFunction = weightFunction
            )
        
        mixed.lmer <- mapply(
            spatialMEM,
            spatAssoc = pairwiseAssoc,
            from = m1,
            to = m2,
            MoreArgs = MoreArgs2,
            SIMPLIFY = FALSE
        )
        df <- cleanMEM(mixed.lmer, nsim)
    }
    
    
    
    df$pairwiseAssoc <- pairwiseAssoc
    df$comparisons <- data.frame(from = m1,
                                 to = m2,
                                 labels = labels)
    
    df <- new('SpicyResults', df)
    df
}

cleanLM <- function(linearModels, nsim) {
    if (length(nsim) > 0) {
        boot <- lapply(linearModels, spatialLMBootstrap, nsim = nsim)
        #p <- do.call(rbind, p)
        tBoot <- lapply(boot, function(coef) {
            coef <- as.data.frame(t(coef))
            coef <- split(coef, c("coefficient", "se", "p.value"))
            
        })
        
        df <- apply(do.call(rbind, tBoot), 2, function(x)
            do.call(rbind, x))
        df <- lapply(df, function(x) {
            rownames(x) <- names(linearModels)
            x
        })
    } else {
        tLm <- lapply(linearModels, function(LM) {
            coef <- as.data.frame(t(summary(LM)$coef))
            coef <-
                split(coef, c("coefficient", "se", "statistic", "p.value"))
        })
        
        df <- apply(do.call(rbind, tLm), 2, function(x)
            do.call(rbind, x))
        df <- lapply(df, function(x) {
            rownames(x) <- names(linearModels)
            x
        })
    }
    df
}

cleanMEM <- function(mixed.lmer, nsim) {
    if (length(nsim) > 0) {
        boot <- lapply(mixed.lmer, spatialMEMBootstrap, nsim = nsim)
        #p <- do.call(rbind, p)
        tBoot <- lapply(boot, function(coef) {
            coef <- as.data.frame(t(coef))
            coef <- split(coef, c("coefficient", "se", "p.value"))
        })
        
        
        df <- apply(do.call(rbind, tBoot), 2, function(x)
            do.call(rbind, x))
        df <- lapply(df, function(x) {
            rownames(x) <- names(mixed.lmer)
            x
        })
        
    } else {
        tLmer <- lapply(mixed.lmer, function(lmer) {
            coef <- as.data.frame(t(summary(lmer)$coef))
            coef <-
                split(coef,
                      c("coefficient", "se", "df", "statistic", "p.value"))
        })
        
        df <- apply(do.call(rbind, tLmer), 2, function(x)
            do.call(rbind, x))
        df <- lapply(df, function(x) {
            rownames(x) <- names(mixed.lmer)
            x
        })
        
    }
    df
}

#' Get statistic from pairwise L curve of a single image.
#'
#' @param cells A SegmentedCells or data frame that contains at least the 
#' variables x and y, giving the location coordinates of each cell, and cellType.
#' @param from The 'from' cellType for generating the L curve.
#' @param to The 'to' cellType for generating the L curve.
#' @param dist The distance at which the statistic is obtained.
#'
#' @return Statistic from pairwise L curve of a single image.
#'
#'
#' @examples
#' data("melanomaResponders")
#' pairAssoc <- getPairwise(melanomaResponders)
#' @export
getPairwise <- function(cells, from, to, dist = NULL) {
    cells2 <- cellSummary(cells, bind = FALSE)

    pairwiseVals <- lapply(cells2,
                           getStat,
                           from = from,
                           to = to,
                           dist = dist)
    
    unlist(pairwiseVals)
}


#' @importFrom spatstat Lcross
getStat <- function(cells, from, to, dist) {
    pppCell <- pppGenerate(cells)
    
    L <- tryCatch({
        Lcross(pppCell,
               from = from,
               to = to,
               correction = "best")
    }, error = function(e) {
        
    })
    
    if (!is(L,"fv")) {
        return(NA)
    }
    
    if (is.null(dist))
        dist <- max(L$r)
    
    theo = L$theo[L$r <= dist]
    iso = L$iso[L$r <= dist]
    mean(iso - theo)
}

# Performs bootstrapping to estimate p-value.

#' @importFrom lme4 fixef
spatialMEMBootstrap <- function(mixed.lmer, nsim = 19) {
    functionToReplicate <- function(x) {
        
        toGet <- sample(nrow(x@frame), replace = TRUE)
        
        spatAssocBoot <- x@frame$spatAssoc[toGet]
        conditionBoot <- x@frame$condition[toGet]
        subjectBoot <- x@frame$subject[toGet]
        weightsBoot <- x@frame$`(weights)`[toGet]
        
        spatialDataBoot <- data.frame(spatAssoc = spatAssocBoot,
                                      condition = conditionBoot,
                                      subject = subjectBoot)
        
        mixed.lmer1 <- lmer(spatAssoc ~ condition + (1|subject),
                            data = spatialDataBoot,
                            weights = weightsBoot)
        
        
        
        summary(mixed.lmer1)$coef[2, "statistic"]
    }
    
    stats <- replicate(nsim, functionToReplicate(x = mixed.lmer))
    stats <- t(stats)
    fe <- fixef(mixed.lmer)
    pval <- mean(abs(stat)>abs(summary(mixed.lmer)$coef[2, "statistic"]))
    df <-
        data.frame(
            coefficient = fe,
            se = apply(stats, 2, stats::sd),
            p.value = pval
        )
    df
}

#' @importFrom stats p.adjust
.show_SpicyResults <- function(df) {
    pval <- as.data.frame(df$p.value)
    cond <- colnames(pval)[grep('condition', colnames(pval))]
    message(df$test)
    message("Number of cell type pairs: ", nrow(pval), "\n")
    message("Number of differentially localised cell type pairs: \n")
    if (nrow(pval) == 1)
        print(sum(pval[cond] < 0.05))
    if (nrow(pval) > 1)
        print(colSums(apply(pval[cond], 2, p.adjust, 'fdr') < 0.05))
    
}
setMethod("show", signature(object = "SpicyResults"), function(object) {
    .show_SpicyResults(object)
})

#' @importFrom lmerTest lmer
#' @importFrom stats predict
spatialMEM <-
    function(spatAssoc,
             from,
             to,
             cells,
             subject,
             condition,
             covariates,
             weightFunction) {
        
        spatAssoc[is.na(spatAssoc)] <- 0
        cellCounts <- table(imageID(cells), cellType(cells))

        count1 <- cellCounts[, from]
        count2 <- cellCounts[, to]
        # filter <- !is.na(spatAssoc)
        # 
        # if (sum(filter) < 3)
        #     return(NA)
        
        pheno <- as.data.frame(imagePheno(cells))
        spatialData <-
            data.frame(spatAssoc,
                       condition = pheno[, condition],
                       subject = pheno[, subject],
                       pheno[covariates])
        
        if (is.null(weightFunction)) {
            w <- rep(1, length(count1))
        } else{
            z1 <- predict(weightFunction, data.frame(count1ToWeight = count1, 
                                                     count2ToWeight = count2))
            w <- 1 / sqrt(z1 - min(z1) + 1)
            w <- w / sum(w)
        }
        
        formula <- 'spatAssoc ~ condition + (1|subject)'
        
        if (!is.null(covariates))
            formula <-
            paste('spatAssoc ~ condition + (1|subject)',
                  paste(covariates, collapse = '+'),
                  sep = "+")
        
        mixed.lmer <- lmer(formula(formula),
                           data = spatialData,
                           weights = w)
        mixed.lmer
    }

#' @importFrom stats predict lm
spatialLM <-
    function(spatAssoc,
             from,
             to,
             cells,
             condition,
             covariates,
             weightFunction) {
        cellCounts <- table(imageID(cells), cellType(cells))
        
        count1 <- cellCounts[, from]
        count2 <- cellCounts[, to]
        
        pheno <- as.data.frame(imagePheno(cells))
        #print(pheno)
        spatialData <-
            data.frame(spatAssoc, condition = pheno[, condition], pheno[covariates])
        # spatialData <- spatialData[filter, ]
        # count1 <- count1[filter]
        # count2 <- count2[filter]
        #print(spatialData)
        
        if (is.null(weightFunction)) {
            w <- rep(1, length(count1))
        } else {
            z1 <- predict(weightFunction, data.frame(count1ToWeight = count1, 
                                                     count2ToWeight = count2))
            w <- 1 / sqrt(z1 - min(z1) + 1)
            w <- w / sum(w)
        }
        
        formula <- 'spatAssoc ~ condition'
        
        if (!is.null(covariates))
            formula <-
            paste('spatAssoc ~ condition',
                  paste(covariates, collapse = '+'),
                  sep = "+")
        lm1 <- lm(formula(formula),
                  data = spatialData,
                  weights = w)
        
        lm1
    }

#' @importFrom stats sd
spatialLMBootstrap <- function(linearModels, nsim=19) {
    functionToReplicate <- function(x) {
        
        toGet <- sample(nrow(x$model), replace = TRUE)
        
        spatAssocBoot <- x$model$spatAssoc[toGet]
        conditionBoot <- x$model$condition[toGet]
        weightsBoot <- x$weights[toGet]
        
        spatialDataBoot <- data.frame(spatAssoc = spatAssocBoot,
                                      condition = conditionBoot)
        
        lm1 <- lm(spatAssoc ~ condition,
                  data = spatialDataBoot,
                  weights = weightsBoot)
        
        lm1$coefficients[2]
    }
    stats <- replicate(nsim, functionToReplicate(x = linearModels))
    
    fe <- linearModels$coefficients[2]
    
    pval <- pmin(mean(stats < 0), mean(stats > 0)) * 2
    df <-
        data.frame(
            coefficient = fe,
            se = sd(stats),
            p.value = pval
        )
    df
}

#' Plots result of signifPlot.
#'
#' @param results Data frame obtained from spicy.
#' @param fdr TRUE if FDR correction is used.
#' @param breaks Vector of 3 numbers giving breaks used in pheatmap. The first 
#' number is the minimum, the second is the maximum, the third is the number of breaks.
#' @param colors Vector of colours to use in pheatmap.
#' @param marksToPlot Vector of marks to include in pheatmap.
#'
#' @return a pheatmap object
#'
#' @examples
#' data(spicyTest)
#' signifPlot(spicyTest, breaks=c(-3, 3, 0.5))
#' 
#' @export
#' @importFrom pheatmap pheatmap
#' @importFrom grDevices colorRampPalette
#' @importFrom stats p.adjust
signifPlot <- function(results,
                       fdr = FALSE,
                       breaks = c(-5, 5, 0.5),
                       colors = c("blue", "white", "red"),
                       marksToPlot = NULL) {
    pVal <- results$p.value[,2]
    marks <- unique(results$comparisons$from)
    
    if (is.null(marksToPlot)) marksToPlot <- marks
    
    if (min(pVal) == 0) {
        pVal[pVal == 0] <-
            pVal[pVal == 0] + 10 ^ floor(log10(min(pVal[pVal > 0])))
    }
    
    if (fdr) {
        pVal <- p.adjust(pVal, method = "fdr")
    }
    
    isGreater <- results$coefficient[,2] > 0
    
    pVal <- log10(pVal)
    
    pVal[isGreater] <- abs(pVal[isGreater])
    
    pVal <- matrix(pVal, nrow = length(marks))
    colnames(pVal) <- marks
    rownames(pVal) <- marks
    
    
    breaks <- seq(from = breaks[1], to = breaks[2], by = breaks[3])
    pal <- colorRampPalette(colors)(length(breaks))
    
    heatmap <- pheatmap(
        pVal[marksToPlot, marksToPlot],
        color = pal,
        breaks = breaks,
        cluster_rows = FALSE,
        cluster_cols = FALSE
    )
    
    heatmap
}

#' @importFrom spatstat ppp
pppGenerate <- function(cells) {
    pppCell <- ppp(
        cells$x,
        cells$y,
        xrange = c(0, max(cells$x)),
        yrange = c(0, max(cells$y)),
        marks = cells$cellType
    )
    
    pppCell
}